{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyright Reverse Engineering Pyright is a static type checker for Python, developed by Microsoft. It is designed to provide fast and accurate type checking, making it a valuable tool for Python developers who want to ensure code quality and maintainability. Architecture Overview The pyright LSP is a different process, communicate with the LSP client (vscode) using ICP and, the two threads are communicating with node internal communication protocol (syncronously). The pyright LSP has two components: foreground thread : it has a program instance background thread : it has another copy of the program instance they both are in sync to maintain the same state 1 The reason for having two instances is to make the LSP responsive, so that the background thread can do the heavy lifting of analyzing the code without blocking the main thread. The background thread will only do the diagnostic work and send the analysis result to the foreground thread, and thats when we can see the red squiggles in the editor. Other tasks are run in both foreground and background program instances to maintain the same state and it's important to have a forground instance to make the LSP responsive. The diagnostics will send from the worker thread serialized and the main theads will deserialize it and update the state of the program instance 2 . System Architecture The architecture diagram is from https://deepwiki.com/microsoft/pyright pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts \u21a9 pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts:308 \u21a9","title":"Home"},{"location":"#pyright-reverse-engineering","text":"Pyright is a static type checker for Python, developed by Microsoft. It is designed to provide fast and accurate type checking, making it a valuable tool for Python developers who want to ensure code quality and maintainability.","title":"Pyright Reverse Engineering"},{"location":"#architecture-overview","text":"The pyright LSP is a different process, communicate with the LSP client (vscode) using ICP and, the two threads are communicating with node internal communication protocol (syncronously). The pyright LSP has two components: foreground thread : it has a program instance background thread : it has another copy of the program instance they both are in sync to maintain the same state 1 The reason for having two instances is to make the LSP responsive, so that the background thread can do the heavy lifting of analyzing the code without blocking the main thread. The background thread will only do the diagnostic work and send the analysis result to the foreground thread, and thats when we can see the red squiggles in the editor. Other tasks are run in both foreground and background program instances to maintain the same state and it's important to have a forground instance to make the LSP responsive. The diagnostics will send from the worker thread serialized and the main theads will deserialize it and update the state of the program instance 2 .","title":"Architecture Overview"},{"location":"#system-architecture","text":"The architecture diagram is from https://deepwiki.com/microsoft/pyright pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts \u21a9 pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts:308 \u21a9","title":"System Architecture"},{"location":"archit_ref/","text":"Architecture References Foreground / Background Program instances The program (in jaclang its the JacProgram ) object is created in the backgroundAnalysisProgram.ts file, the BackgroundAnalysisProgram instance will also create a BackgroundAnalysis instance (that is the other thread running the background analysis), the forground program instance will be cloned by the background thread to maintain the same state. pyright\\packages\\pyright-internal\\src\\analyzer\\backgroundAnalysisProgram.ts this._program = new Program( this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, serviceId ); Here is a snippet of the setFileOpened method that syncs the state of both foreground and background program instances. setFileOpened(fileUri: Uri, version: number | null, contents: string, options: OpenFileOptions) { this._backgroundAnalysis?.setFileOpened(fileUri, version, contents, options); this._program.setFileOpened(fileUri, version, contents, options); } Since the above setFileOpened method is not computation heavy, it's done in both threads however the analysis will only running in the background thread (if it's enabled), Here is the reference. startAnalysis(token: CancellationToken): boolean { if (this._backgroundAnalysis) { this._backgroundAnalysis.startAnalysis(token); return false; } return analyzeProgram( this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), token ); } When the above analyzeProgram is called, it will run the background thread and that will collect the diagnostics and send it to the foreground thread. Analysis Service The AnalyzerService has a reference to the above BackgroundAnalysisProgram instance, it is responsible for managing the background analysis and providing services to the LSP client. The AnalyzerService is created in the service.ts file. AnalyzerService is a reference in the LSP server. pyright\\packages\\pyright-internal\\src\\analyzer\\service.ts export class AnalyzerService { protected readonly options: AnalyzerServiceOptions; private readonly _backgroundAnalysisProgram: BackgroundAnalysisProgram; private readonly _serviceProvider: ServiceProvider; private _instanceName: string; private _executionRootUri: Uri; private _typeStubTargetUri: Uri | undefined;","title":"Architecture Reference"},{"location":"archit_ref/#architecture-references","text":"","title":"Architecture References"},{"location":"archit_ref/#foreground-background-program-instances","text":"The program (in jaclang its the JacProgram ) object is created in the backgroundAnalysisProgram.ts file, the BackgroundAnalysisProgram instance will also create a BackgroundAnalysis instance (that is the other thread running the background analysis), the forground program instance will be cloned by the background thread to maintain the same state. pyright\\packages\\pyright-internal\\src\\analyzer\\backgroundAnalysisProgram.ts this._program = new Program( this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, serviceId ); Here is a snippet of the setFileOpened method that syncs the state of both foreground and background program instances. setFileOpened(fileUri: Uri, version: number | null, contents: string, options: OpenFileOptions) { this._backgroundAnalysis?.setFileOpened(fileUri, version, contents, options); this._program.setFileOpened(fileUri, version, contents, options); } Since the above setFileOpened method is not computation heavy, it's done in both threads however the analysis will only running in the background thread (if it's enabled), Here is the reference. startAnalysis(token: CancellationToken): boolean { if (this._backgroundAnalysis) { this._backgroundAnalysis.startAnalysis(token); return false; } return analyzeProgram( this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), token ); } When the above analyzeProgram is called, it will run the background thread and that will collect the diagnostics and send it to the foreground thread.","title":"Foreground / Background Program instances"},{"location":"archit_ref/#analysis-service","text":"The AnalyzerService has a reference to the above BackgroundAnalysisProgram instance, it is responsible for managing the background analysis and providing services to the LSP client. The AnalyzerService is created in the service.ts file. AnalyzerService is a reference in the LSP server. pyright\\packages\\pyright-internal\\src\\analyzer\\service.ts export class AnalyzerService { protected readonly options: AnalyzerServiceOptions; private readonly _backgroundAnalysisProgram: BackgroundAnalysisProgram; private readonly _serviceProvider: ServiceProvider; private _instanceName: string; private _executionRootUri: Uri; private _typeStubTargetUri: Uri | undefined;","title":"Analysis Service"}]}