{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyright Reverse Engineering Pyright is a static type checker for Python, developed by Microsoft. It is designed to provide fast and accurate type checking, making it a valuable tool for Python developers who want to ensure code quality and maintainability. Architecture Overview The pyright LSP is a different process, communicate with the LSP client (vscode) using ICP and, the two threads are communicating with node internal communication protocol (syncronously). The pyright LSP has two components: foreground thread : it has a program instance background thread : it has another copy of the program instance they both are in sync to maintain the same state 1 The reason for having two instances is to make the LSP responsive, so that the background thread can do the heavy lifting of analyzing the code without blocking the main thread. The background thread will only do the diagnostic work and send the analysis result to the foreground thread, and thats when we can see the red squiggles in the editor. Other tasks are run in both foreground and background program instances to maintain the same state and it's important to have a forground instance to make the LSP responsive. The diagnostics will send from the worker thread serialized and the main theads will deserialize it and update the state of the program instance 2 . System Architecture The architecture diagram is from https://deepwiki.com/microsoft/pyright pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts \u21a9 pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts:308 \u21a9","title":"Home"},{"location":"#pyright-reverse-engineering","text":"Pyright is a static type checker for Python, developed by Microsoft. It is designed to provide fast and accurate type checking, making it a valuable tool for Python developers who want to ensure code quality and maintainability.","title":"Pyright Reverse Engineering"},{"location":"#architecture-overview","text":"The pyright LSP is a different process, communicate with the LSP client (vscode) using ICP and, the two threads are communicating with node internal communication protocol (syncronously). The pyright LSP has two components: foreground thread : it has a program instance background thread : it has another copy of the program instance they both are in sync to maintain the same state 1 The reason for having two instances is to make the LSP responsive, so that the background thread can do the heavy lifting of analyzing the code without blocking the main thread. The background thread will only do the diagnostic work and send the analysis result to the foreground thread, and thats when we can see the red squiggles in the editor. Other tasks are run in both foreground and background program instances to maintain the same state and it's important to have a forground instance to make the LSP responsive. The diagnostics will send from the worker thread serialized and the main theads will deserialize it and update the state of the program instance 2 .","title":"Architecture Overview"},{"location":"#system-architecture","text":"The architecture diagram is from https://deepwiki.com/microsoft/pyright pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts \u21a9 pyright\\packages\\pyright-internal\\src\\backgroundAnalysisBase.ts:308 \u21a9","title":"System Architecture"},{"location":"archit_ref/","text":"Architecture References Foreground / Background Program instances The program (in jaclang its the JacProgram ) object is created in the backgroundAnalysisProgram.ts file, the BackgroundAnalysisProgram instance will also create a BackgroundAnalysis instance (that is the other thread running the background analysis), the forground program instance will be cloned by the background thread to maintain the same state. pyright\\packages\\pyright-internal\\src\\analyzer\\backgroundAnalysisProgram.ts this._program = new Program( this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, serviceId ); Here is a snippet of the setFileOpened method that syncs the state of both foreground and background program instances. setFileOpened(fileUri: Uri, version: number | null, contents: string, options: OpenFileOptions) { this._backgroundAnalysis?.setFileOpened(fileUri, version, contents, options); this._program.setFileOpened(fileUri, version, contents, options); } Since the above setFileOpened method is not computation heavy, it's done in both threads however the analysis will only running in the background thread (if it's enabled), Here is the reference. startAnalysis(token: CancellationToken): boolean { if (this._backgroundAnalysis) { this._backgroundAnalysis.startAnalysis(token); return false; } return analyzeProgram( this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), token ); } When the above analyzeProgram is called, it will run the background thread and that will collect the diagnostics and send it to the foreground thread. Analysis Service The AnalyzerService has a reference to the above BackgroundAnalysisProgram instance, it is responsible for managing the background analysis and providing services to the LSP client. The AnalyzerService is created in the service.ts file. AnalyzerService is a reference in the LSP server. pyright\\packages\\pyright-internal\\src\\analyzer\\service.ts export class AnalyzerService { protected readonly options: AnalyzerServiceOptions; private readonly _backgroundAnalysisProgram: BackgroundAnalysisProgram; private readonly _serviceProvider: ServiceProvider; private _instanceName: string; private _executionRootUri: Uri; private _typeStubTargetUri: Uri | undefined;","title":"Architecture References"},{"location":"archit_ref/#architecture-references","text":"","title":"Architecture References"},{"location":"archit_ref/#foreground-background-program-instances","text":"The program (in jaclang its the JacProgram ) object is created in the backgroundAnalysisProgram.ts file, the BackgroundAnalysisProgram instance will also create a BackgroundAnalysis instance (that is the other thread running the background analysis), the forground program instance will be cloned by the background thread to maintain the same state. pyright\\packages\\pyright-internal\\src\\analyzer\\backgroundAnalysisProgram.ts this._program = new Program( this.importResolver, this.configOptions, this._serviceProvider, undefined, this._disableChecker, serviceId ); Here is a snippet of the setFileOpened method that syncs the state of both foreground and background program instances. setFileOpened(fileUri: Uri, version: number | null, contents: string, options: OpenFileOptions) { this._backgroundAnalysis?.setFileOpened(fileUri, version, contents, options); this._program.setFileOpened(fileUri, version, contents, options); } Since the above setFileOpened method is not computation heavy, it's done in both threads however the analysis will only running in the background thread (if it's enabled), Here is the reference. startAnalysis(token: CancellationToken): boolean { if (this._backgroundAnalysis) { this._backgroundAnalysis.startAnalysis(token); return false; } return analyzeProgram( this._program, this._maxAnalysisTime, this._configOptions, this._onAnalysisCompletion, this._serviceProvider.console(), token ); } When the above analyzeProgram is called, it will run the background thread and that will collect the diagnostics and send it to the foreground thread.","title":"Foreground / Background Program instances"},{"location":"archit_ref/#analysis-service","text":"The AnalyzerService has a reference to the above BackgroundAnalysisProgram instance, it is responsible for managing the background analysis and providing services to the LSP client. The AnalyzerService is created in the service.ts file. AnalyzerService is a reference in the LSP server. pyright\\packages\\pyright-internal\\src\\analyzer\\service.ts export class AnalyzerService { protected readonly options: AnalyzerServiceOptions; private readonly _backgroundAnalysisProgram: BackgroundAnalysisProgram; private readonly _serviceProvider: ServiceProvider; private _instanceName: string; private _executionRootUri: Uri; private _typeStubTargetUri: Uri | undefined;","title":"Analysis Service"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/","text":"Pyright control-flow graph (CFG) and type checking integration This document explains how Pyright constructs, traverses, and uses its control-flow graph (CFG) for type narrowing and reachability. It includes exact references to files and functions in this codebase and Python-like pseudocode for the core algorithms. Primary sources in this repo CFG node types and flags: packages/pyright-internal/src/analyzer/codeFlowTypes.ts CFG traversal and type narrowing engine: packages/pyright-internal/src/analyzer/codeFlowEngine.ts CFG construction (binder/walker): packages/pyright-internal/src/analyzer/binder.ts Type evaluator integration: packages/pyright-internal/src/analyzer/typeEvaluator.ts CFG formatting (debug): packages/pyright-internal/src/analyzer/codeFlowUtils.ts Node-attached analysis info: packages/pyright-internal/src/analyzer/analyzerNodeInfo.ts Related helpers: packages/pyright-internal/src/analyzer/typeGuards.ts , packages/pyright-internal/src/analyzer/patternMatching.ts (used for narrowing callbacks) Related Pyright docs - Type narrowing and reachability concepts: docs/type-concepts-advanced.md (sections \"Type Narrowing\", \"Reachability\", \"Narrowing for Implied Else\"). High-level architecture The binder ( binder.ts ) walks the parse tree and builds a flow graph of FlowNodes (edges are stored as \"antecedents\" pointing backward). It also attaches the current flow point to parse nodes via AnalyzerNodeInfo.setFlowNode and end-of-block nodes via setAfterFlowNode . The type evaluator ( typeEvaluator.ts ) asks a CodeFlowEngine ( codeFlowEngine.ts ) to compute: The narrowed type of an expression at a program point (using CodeFlowAnalyzer.getTypeFromCodeFlow ). The reachability of a node (using CodeFlowEngine.getFlowNodeReachability ). Narrowing walks backward through the CFG from the current node to its antecedents, applying assignment effects and conditional/pattern guards; branches are unioned; loops use a fixed-point iteration with convergence limits; try/finally and context managers add special gates. CFG node kinds and flags (where defined) File: codeFlowTypes.ts Enum FlowFlags defines node kinds including Start, BranchLabel, LoopLabel, Assignment, Unbind, WildcardImport, TrueCondition, FalseCondition, Call, PreFinallyGate, PostFinally, VariableAnnotation, PostContextManager, TrueNeverCondition, FalseNeverCondition, NarrowForPattern, ExhaustedMatch. Node interfaces: FlowNode , FlowLabel / FlowBranchLabel , FlowAssignment , FlowVariableAnnotation , FlowWildcardImport , FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , FlowCall , FlowPreFinallyGate , FlowPostFinally , FlowPostContextManagerLabel . Reference-key helpers: isCodeFlowSupportedForReference , createKeyForReference , createKeysForReferenceSubexpressions . Key idea: nodes reference antecedents (previous flow points), enabling efficient backward traversal from a point-of-use. CFG construction (binder) File: binder.ts Per execution scope (module/function/lambda), the binder maintains _currentFlowNode and attaches it to parse nodes: AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!) . Entry/start nodes: _createStartFlowNode() sets FlowFlags.Start when entering a module or function. Example: module and function bind paths. Branches and loops: _createBranchLabel (creates FlowBranchLabel ), _finishFlowLabel , _addAntecedent , _createLoopLabel (for while , for , comprehensions), _bindLoopStatement . visitIf , visitWhile , visitTernary , logical ops ( visitBinaryOperation / visitUnaryOperation ) wire true/false paths using _bindConditional and _createFlowConditional that produce FlowCondition nodes with TrueCondition / FalseCondition / TrueNeverCondition / FalseNeverCondition flags. Assignments and variable annotations: _createFlowAssignment builds FlowAssignment nodes (with optional Unbind for deletions). _createVariableAnnotationFlowNode adds FlowVariableAnnotation to separate annotation and name binding. Calls and exceptions: _createCallFlowNode emits FlowCall and marks that exceptions can route to except targets. visitRaise and return paths connect to structural unreachable nodes and finally targets. Try/except/finally: visitTry builds the special \"finally gate\": emits FlowPreFinallyGate and FlowPostFinally (see ASCII diagram comment in visitTry ). With/async with: visitWith builds FlowPostContextManagerLabel nodes that model context managers that may swallow exceptions, interpreted by the engine. Match/case and pattern narrowing: visitMatch emits per-case narrowing nodes FlowNarrowForPattern and a closing FlowExhaustedMatch gate if the match can be proven exhaustive. Misc: Wildcard import: _createFlowWildcardImport builds FlowWildcardImport nodes. Complexity tracking (to short-circuit huge graphs): _codeFlowComplexity updated in _finishFlowLabel and per-node; recorded via AnalyzerNodeInfo.setCodeFlowComplexity . References - Start node: _createStartFlowNode (binder.ts) - Conditional wiring: _bindConditional , _createFlowConditional (binder.ts) - If/While: visitIf , visitWhile (binder.ts) - For/Comprehensions: visitFor , visitComprehension , _bindLoopStatement , _createLoopLabel (binder.ts) - Try/finally: visitTry and nodes FlowPreFinallyGate , FlowPostFinally (binder.ts/codeFlowTypes.ts) - With: visitWith , context manager label creation (binder.ts) - Match/pattern: visitMatch , _createFlowNarrowForPattern , _createFlowExhaustedMatch (binder.ts) - Assignments: _createFlowAssignment (binder.ts) - Variable annotations: _createVariableAnnotationFlowNode (binder.ts) - Call nodes: _createCallFlowNode (binder.ts) - Wildcard imports: _createFlowWildcardImport (binder.ts) How the type evaluator uses the CFG File: typeEvaluator.ts Creates a CodeFlowEngine via getCodeFlowEngine(evaluator, speculativeTypeTracker) and caches a CodeFlowAnalyzer per execution scope and starting type ( getCodeFlowAnalyzerForNode ). Entry points that call into the engine: Narrowing for a reference: getFlowTypeOfReference(reference, startNode?, options?) \u2192 obtains flowNode via AnalyzerNodeInfo.getFlowNode , checks scope\u2019s codeFlowExpressions set, then calls CodeFlowAnalyzer.getTypeFromCodeFlow(flowNode, reference, options) . Reachability queries: getNodeReachability , getAfterNodeReachability use codeFlowEngine.getFlowNodeReachability . Complexity limit: checkCodeFlowTooComplex(node) consults AnalyzerNodeInfo.getCodeFlowComplexity(scopeNode) vs maxCodeComplexity to short-circuit overly-complex graphs. Special usages: Return type inference for unannotated functions uses code flow limits like maxReturnTypeInferenceCodeFlowComplexity and maxReturnCallSiteTypeInferenceCodeFlowComplexity . codeFlowAnalyzerCache stores analyzers keyed by execution scope id and optional typeAtStart to stabilize narrowing across evaluations. Key references in typeEvaluator.ts - getFlowTypeOfReference (calls getCodeFlowAnalyzerForNode , analyzer.getTypeFromCodeFlow ) - getNodeReachability , getAfterNodeReachability (call codeFlowEngine.getFlowNodeReachability ) - getCodeFlowAnalyzerForNode , codeFlowAnalyzerCache (analyzer caching) - checkCodeFlowTooComplex , maxCodeComplexity The Code Flow Engine: core algorithms File: codeFlowEngine.ts Factory: getCodeFlowEngine(evaluator, speculativeTypeTracker) returns a CodeFlowEngine with: createCodeFlowAnalyzer() \u2192 CodeFlowAnalyzer exposing getTypeFromCodeFlow(flowNode, reference|undefined, options?) . getFlowNodeReachability(flowNode, sourceFlowNode?, ignoreNoReturn?) \u2192 reachability over the CFG. narrowConstrainedTypeVar(flowNode, typeVar) \u2192 narrows constrained TypeVars across guards/patterns. printControlFlowGraph \u2192 debug printing with formatControlFlowGraph . getTypeFromCodeFlow: backward traversal with narrowing and caching Per-reference caches A separate cache per reference key: combines createKeyForReference(reference) and an optional targetSymbolId to scope cached types. Caches entries as either a concrete Type or an IncompleteType record with incompleteSubtypes for loops. Walk-from-current algorithm Starting at a flowNode , repeatedly: Return cached type if available (respecting \u201cpending\u201d/incomplete generation guards to avoid recursion and churn). Short-circuit on Unreachable* nodes with Never . Skip-through linear nodes updating state: FlowVariableAnnotation , FlowWildcardImport , FlowAssignment.antecedent , FlowCall.antecedent , etc. FlowCall : if isCallNoReturn true, stop exploration on this path (treat as unreachable upstream). FlowAssignment matching the reference: evaluate RHS type via evaluator.evaluateTypesForStatement , handle Unbind (yield UnboundType except for index/member deletes), handle partial-match kill of prior narrowings; special-case TypedDict key assignment narrowing when target is x['literal_key'] . Conditional nodes FlowCondition with True/False / TrueNever/FalseNever : If reference matches, compute typeNarrowingCallback to refine the antecedent type; if Never under implied-else gate, block further exploration. Pattern nodes: FlowNarrowForPattern : evaluate case/match for subject narrowing; can also narrow subexpressions in subject . FlowExhaustedMatch : if subject narrowed to Never at bottom, gate further exploration; otherwise project narrowed type to subexpressions. Finally-gates: FlowPreFinallyGate / FlowPostFinally : toggles a closed-gate set and uses speculative mode inside finally to evaluate \u201cgate-open\u201d types safely. Context managers: FlowPostContextManagerLabel : consults isExceptionContextManager to decide if this path should be blocked based on blockIfSwallowsExceptions . Start node: return options.typeAtStart if provided. Join nodes: FlowBranchLabel : union of types from all antecedents. FlowLabel with LoopLabel : fixed-point over antecedents; track per-antecedent incomplete subtype entries; apply a convergence limit; remove \u201cincomplete unknowns\u201d to encourage convergence. Pseudocode sketch (Python-like, simplified): # Inputs: flowNode, reference (may be None), options # Output: TypeResult(type, isIncomplete) def getTypeFromCodeFlow(flowNode, reference, options): cache = get_cache_for(reference_key(reference, options.target_symbol_id)) def get_from_node(node): while True: entry = cache.lookup(node) if entry.is_complete(): return entry if entry.is_incomplete_for_current_gen(): return entry.clean_union() if cache.is_pending(node): return Unknown(incomplete=True) if node.has_flag('UnreachableStructural') or node.has_flag('UnreachableStaticCondition'): return cache.store(node, Never) if node.is_any('VariableAnnotation', 'WildcardImport'): node = node.antecedent; continue if node.is_call(): if is_call_noreturn(node): return cache.store(node, None) # stop path node = node.antecedent; continue if node.is_assignment(): if matches_reference(node.target, reference, options.target_symbol_id): if node.is_unbind and not is_index_or_member_delete(reference): return cache.store(node, Unbound) rhs = eval_rhs_type(node) return cache.store(node, rhs.type, incomplete=rhs.isIncomplete) if partial_match(node.target, reference): return options.typeAtStart node = node.antecedent; continue if node.is_branch_label(): if reference and unaffected_by_branch(node, reference): node = node.pre_branch_antecedent; continue return join([get_from_node(a) for a in node.antecedents]) if node.is_loop_label(): return solve_loop(node) if node.is_condition(): if reference and not options.skipConditionalNarrowing: narrowed = apply_narrowing(reference, node.expression, positive=node.is_true()) if narrowed is not None: return cache.store(node, narrowed.type, incomplete=narrowed.isIncomplete) node = node.antecedent; continue if node.is_narrow_for_pattern(): res = eval_case_or_match(node.statement) if not reference: if is_never(res.type): return cache.store(node, None, incomplete=res.isIncomplete) else: narrowed = project_subject_narrowing(reference, node.subject, res.type) return cache.store(node, narrowed, incomplete=res.isIncomplete) node = node.antecedent; continue if node.is_exhausted_match(): subj = eval_match(node).type if is_never(subj): return cache.store(node, Never) if reference: narrowed = project_subject_narrowing(reference, node.subject_expression, subj) return cache.store(node, narrowed) node = node.antecedent; continue if node.is_pre_finally_gate(): return evaluate_gate_closed(node) if node.is_post_finally(): return evaluate_gate_open(node) if node.is_post_context_manager_label(): if should_block_path(node): return cache.store(node, None) if node.is_start(): return cache.store(node, options.typeAtStart.type, incomplete=options.typeAtStart.isIncomplete) raise AssertionError('Unexpected FlowNode kind') return get_from_node(flowNode) getFlowNodeReachability: structural + type-based reachability Walks backward like getTypeFromCodeFlow but returns a Reachability enum and memoizes per (flowNode, sourceFlowNode?) . Short-circuits with: Structural unreachable flags, unconditional Start checks, and caching. NoReturn calls ( FlowCall ) unless ignoreNoReturn=True . FlowPostContextManagerLabel when no context manager swallows exceptions. Conditional narrowing where the type becomes Never . Pattern narrowing resulting in Never . Joins at labels consider whether any antecedent is reachable; otherwise preserves reason (by-analysis vs static-condition vs structural). Pseudocode sketch: def getFlowNodeReachability(flowNode, sourceFlowNode=None, ignoreNoReturn=False): visited = set(); closed_finally = set(); cache = {} def reach(node): if (node, sourceFlowNode) in cache: return cache[(node, sourceFlowNode)] if node in visited: return 'UnreachableStructural' visited.add(node) if node.has_flag('UnreachableStructural'): return store(node, 'UnreachableStructural') if node.has_flag('UnreachableStaticCondition'): return store(node, 'UnreachableStaticCondition') if node is sourceFlowNode: return store(node, 'Reachable') if node.is_any('VariableAnnotation','Assignment','WildcardImport','ExhaustedMatch'): return tail(node.antecedent) if node.is_narrow_for_pattern(): t = eval_case_or_match(node.statement) if is_never(t.type): return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_condition(): if narrows_to_never(node): return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_call() and not ignoreNoReturn and is_call_noreturn(node): return store(node, 'UnreachableByAnalysis') if node.is_label(): statuses = [reach(a) for a in node.antecedents] if any(s == 'Reachable' for s in statuses): return store(node, 'Reachable') if any(s == 'UnreachableByAnalysis' for s in statuses): return store(node, 'UnreachableByAnalysis') if any(s == 'UnreachableStaticCondition' for s in statuses): return store(node, 'UnreachableStaticCondition') return store(node, 'UnreachableStructural') if node.is_start(): return store(node, 'Reachable' if sourceFlowNode is None else 'UnreachableByAnalysis') if node.is_pre_finally_gate(): if node.id in closed_finally: return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_post_finally(): was_closed = node.pre_finally_id in closed_finally closed_finally.add(node.pre_finally_id) try: return store(node, reach(node.antecedent)) finally: if not was_closed: closed_finally.remove(node.pre_finally_id) raise AssertionError def store(node, status): cache[(node, sourceFlowNode)] = status return status def tail(next_node): return reach(next_node) return reach(flowNode) Other algorithms in the engine narrowConstrainedTypeVar(flowNode, typeVar) : Traverses back through guards and pattern matches to reduce a constrained TypeVar to a single remaining constraint when possible (e.g., isinstance(x, C) filters constraints to those compatible with C ). Handles labels/loops, Pre/PostFinally, and ignores nodes that don\u2019t affect the TypeVar. isCallNoReturn and isFunctionNoReturn : Determines if a call/site is effectively NoReturn (declared NoReturn ; overloads NoReturn ; coroutine third type arg Never ; or flow proves function never reaches after-node). Caches per call node id. isExceptionContextManager : Detects context managers whose __exit__ / __aexit__ return a truthy bool , indicating exception swallowing. Keys that connect binder and evaluator AnalyzerNodeInfo.setFlowNode / getFlowNode , setAfterFlowNode / getAfterFlowNode attach the current and end-of-block flow nodes to parse nodes. AnalyzerNodeInfo.setCodeFlowExpressions stores a per-scope set of reference keys that actually participate in code flow. typeEvaluator uses this set to skip unnecessary flow analysis. AnalyzerNodeInfo.setCodeFlowComplexity and maxCodeComplexity act as a guardrail against pathological graphs. Debugging: printing the CFG File: codeFlowUtils.ts , exported formatControlFlowGraph(flowNode: FlowNode) produces an ASCII rendering of the graph rooted at a node, with labels for node kinds. Engine hook: codeFlowEngine.printControlFlowGraph calls this utility (behind an internal flag). End-to-end flow 1) Parse \u2192 binder.ts constructs the CFG, attaching flow nodes to parse nodes and tracking affected reference keys and complexity. 2) Type evaluation \u2192 typeEvaluator.ts checks complexity and whether the reference participates in code flow, then calls CodeFlowAnalyzer.getTypeFromCodeFlow with the node attached to that parse node. 3) codeFlowEngine.ts traverses backward, applying assignments/guards, narrowing, handling branches/loops/finally/context managers, pattern matching, and NoReturn detection. 4) Results are memoized to avoid recomputation and prevent recursion. Exact references (file and symbol) CFG node definitions: analyzer/codeFlowTypes.ts FlowFlags , FlowNode , FlowLabel , FlowBranchLabel , FlowAssignment , FlowVariableAnnotation , FlowWildcardImport , FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , FlowCall , FlowPreFinallyGate , FlowPostFinally , FlowPostContextManagerLabel isCodeFlowSupportedForReference , createKeyForReference , createKeysForReferenceSubexpressions CFG construction (binder): analyzer/binder.ts Start: _createStartFlowNode Labels: _createBranchLabel , _createLoopLabel , _finishFlowLabel , _addAntecedent , _bindLoopStatement Conditions: _bindConditional , _createFlowConditional , _bindNeverCondition Visitors building graph: visitIf , visitWhile , visitFor , visitComprehension , visitTernary , visitBinaryOperation , visitUnaryOperation , visitTry , visitWith , visitMatch , visitExcept , visitRaise , visitReturn Assignment/annotation/call/import: _createFlowAssignment , _createVariableAnnotationFlowNode , _createCallFlowNode , _createFlowWildcardImport , _createFlowNarrowForPattern , _createFlowExhaustedMatch Complexity: _codeFlowComplexity and AnalyzerNodeInfo.setCodeFlowComplexity Engine and algorithms: analyzer/codeFlowEngine.ts Factory: getCodeFlowEngine , analyzer: createCodeFlowAnalyzer Narrowing: getTypeFromCodeFlow and helpers for branch/loop/finally nodes Reachability: getFlowNodeReachability TypeVar narrowing: narrowConstrainedTypeVar NoReturn detection: isCallNoReturn , isFunctionNoReturn Context manager detection: isExceptionContextManager Debug: printControlFlowGraph Type evaluator integration: analyzer/typeEvaluator.ts Engine creation and caching: getCodeFlowEngine(...) , getCodeFlowAnalyzerForNode , codeFlowAnalyzerCache Main use sites: getFlowTypeOfReference , getNodeReachability , getAfterNodeReachability Complexity guard: checkCodeFlowTooComplex , constants maxCodeComplexity , maxReturnTypeInferenceCodeFlowComplexity , maxReturnCallSiteTypeInferenceCodeFlowComplexity CFG print utility: analyzer/codeFlowUtils.ts \u2192 formatControlFlowGraph Node info attachment: analyzer/analyzerNodeInfo.ts \u2192 setFlowNode , getFlowNode , setAfterFlowNode , setCodeFlowExpressions , setCodeFlowComplexity Notes on performance and limits Complexity limits in typeEvaluator.ts avoid high-cost analyses: if exceeded, flow analysis is skipped and results are marked incomplete. Loop convergence uses per-antecedent incomplete entries and a convergence attempt limit; \u201cincomplete unknown\u201d subtypes may be removed to help convergence. Per-reference caches prevent repeated traversals; pending guards avoid re-entrant recursion. Appendix: related conceptual docs Repo doc: docs/type-concepts-advanced.md \u2192 Sections \"Type Narrowing\", \"Narrowing for Implied Else\", and \"Reachability\". Online docs: https://microsoft.github.io/pyright/#/docs/type-concepts-advanced and https://microsoft.github.io/pyright/#/docs/internals","title":"Pyright control-flow graph (CFG) and type checking integration"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#pyright-control-flow-graph-cfg-and-type-checking-integration","text":"This document explains how Pyright constructs, traverses, and uses its control-flow graph (CFG) for type narrowing and reachability. It includes exact references to files and functions in this codebase and Python-like pseudocode for the core algorithms. Primary sources in this repo CFG node types and flags: packages/pyright-internal/src/analyzer/codeFlowTypes.ts CFG traversal and type narrowing engine: packages/pyright-internal/src/analyzer/codeFlowEngine.ts CFG construction (binder/walker): packages/pyright-internal/src/analyzer/binder.ts Type evaluator integration: packages/pyright-internal/src/analyzer/typeEvaluator.ts CFG formatting (debug): packages/pyright-internal/src/analyzer/codeFlowUtils.ts Node-attached analysis info: packages/pyright-internal/src/analyzer/analyzerNodeInfo.ts Related helpers: packages/pyright-internal/src/analyzer/typeGuards.ts , packages/pyright-internal/src/analyzer/patternMatching.ts (used for narrowing callbacks) Related Pyright docs - Type narrowing and reachability concepts: docs/type-concepts-advanced.md (sections \"Type Narrowing\", \"Reachability\", \"Narrowing for Implied Else\").","title":"Pyright control-flow graph (CFG) and type checking integration"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#high-level-architecture","text":"The binder ( binder.ts ) walks the parse tree and builds a flow graph of FlowNodes (edges are stored as \"antecedents\" pointing backward). It also attaches the current flow point to parse nodes via AnalyzerNodeInfo.setFlowNode and end-of-block nodes via setAfterFlowNode . The type evaluator ( typeEvaluator.ts ) asks a CodeFlowEngine ( codeFlowEngine.ts ) to compute: The narrowed type of an expression at a program point (using CodeFlowAnalyzer.getTypeFromCodeFlow ). The reachability of a node (using CodeFlowEngine.getFlowNodeReachability ). Narrowing walks backward through the CFG from the current node to its antecedents, applying assignment effects and conditional/pattern guards; branches are unioned; loops use a fixed-point iteration with convergence limits; try/finally and context managers add special gates.","title":"High-level architecture"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#cfg-node-kinds-and-flags-where-defined","text":"File: codeFlowTypes.ts Enum FlowFlags defines node kinds including Start, BranchLabel, LoopLabel, Assignment, Unbind, WildcardImport, TrueCondition, FalseCondition, Call, PreFinallyGate, PostFinally, VariableAnnotation, PostContextManager, TrueNeverCondition, FalseNeverCondition, NarrowForPattern, ExhaustedMatch. Node interfaces: FlowNode , FlowLabel / FlowBranchLabel , FlowAssignment , FlowVariableAnnotation , FlowWildcardImport , FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , FlowCall , FlowPreFinallyGate , FlowPostFinally , FlowPostContextManagerLabel . Reference-key helpers: isCodeFlowSupportedForReference , createKeyForReference , createKeysForReferenceSubexpressions . Key idea: nodes reference antecedents (previous flow points), enabling efficient backward traversal from a point-of-use.","title":"CFG node kinds and flags (where defined)"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#cfg-construction-binder","text":"File: binder.ts Per execution scope (module/function/lambda), the binder maintains _currentFlowNode and attaches it to parse nodes: AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!) . Entry/start nodes: _createStartFlowNode() sets FlowFlags.Start when entering a module or function. Example: module and function bind paths. Branches and loops: _createBranchLabel (creates FlowBranchLabel ), _finishFlowLabel , _addAntecedent , _createLoopLabel (for while , for , comprehensions), _bindLoopStatement . visitIf , visitWhile , visitTernary , logical ops ( visitBinaryOperation / visitUnaryOperation ) wire true/false paths using _bindConditional and _createFlowConditional that produce FlowCondition nodes with TrueCondition / FalseCondition / TrueNeverCondition / FalseNeverCondition flags. Assignments and variable annotations: _createFlowAssignment builds FlowAssignment nodes (with optional Unbind for deletions). _createVariableAnnotationFlowNode adds FlowVariableAnnotation to separate annotation and name binding. Calls and exceptions: _createCallFlowNode emits FlowCall and marks that exceptions can route to except targets. visitRaise and return paths connect to structural unreachable nodes and finally targets. Try/except/finally: visitTry builds the special \"finally gate\": emits FlowPreFinallyGate and FlowPostFinally (see ASCII diagram comment in visitTry ). With/async with: visitWith builds FlowPostContextManagerLabel nodes that model context managers that may swallow exceptions, interpreted by the engine. Match/case and pattern narrowing: visitMatch emits per-case narrowing nodes FlowNarrowForPattern and a closing FlowExhaustedMatch gate if the match can be proven exhaustive. Misc: Wildcard import: _createFlowWildcardImport builds FlowWildcardImport nodes. Complexity tracking (to short-circuit huge graphs): _codeFlowComplexity updated in _finishFlowLabel and per-node; recorded via AnalyzerNodeInfo.setCodeFlowComplexity . References - Start node: _createStartFlowNode (binder.ts) - Conditional wiring: _bindConditional , _createFlowConditional (binder.ts) - If/While: visitIf , visitWhile (binder.ts) - For/Comprehensions: visitFor , visitComprehension , _bindLoopStatement , _createLoopLabel (binder.ts) - Try/finally: visitTry and nodes FlowPreFinallyGate , FlowPostFinally (binder.ts/codeFlowTypes.ts) - With: visitWith , context manager label creation (binder.ts) - Match/pattern: visitMatch , _createFlowNarrowForPattern , _createFlowExhaustedMatch (binder.ts) - Assignments: _createFlowAssignment (binder.ts) - Variable annotations: _createVariableAnnotationFlowNode (binder.ts) - Call nodes: _createCallFlowNode (binder.ts) - Wildcard imports: _createFlowWildcardImport (binder.ts)","title":"CFG construction (binder)"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#how-the-type-evaluator-uses-the-cfg","text":"File: typeEvaluator.ts Creates a CodeFlowEngine via getCodeFlowEngine(evaluator, speculativeTypeTracker) and caches a CodeFlowAnalyzer per execution scope and starting type ( getCodeFlowAnalyzerForNode ). Entry points that call into the engine: Narrowing for a reference: getFlowTypeOfReference(reference, startNode?, options?) \u2192 obtains flowNode via AnalyzerNodeInfo.getFlowNode , checks scope\u2019s codeFlowExpressions set, then calls CodeFlowAnalyzer.getTypeFromCodeFlow(flowNode, reference, options) . Reachability queries: getNodeReachability , getAfterNodeReachability use codeFlowEngine.getFlowNodeReachability . Complexity limit: checkCodeFlowTooComplex(node) consults AnalyzerNodeInfo.getCodeFlowComplexity(scopeNode) vs maxCodeComplexity to short-circuit overly-complex graphs. Special usages: Return type inference for unannotated functions uses code flow limits like maxReturnTypeInferenceCodeFlowComplexity and maxReturnCallSiteTypeInferenceCodeFlowComplexity . codeFlowAnalyzerCache stores analyzers keyed by execution scope id and optional typeAtStart to stabilize narrowing across evaluations. Key references in typeEvaluator.ts - getFlowTypeOfReference (calls getCodeFlowAnalyzerForNode , analyzer.getTypeFromCodeFlow ) - getNodeReachability , getAfterNodeReachability (call codeFlowEngine.getFlowNodeReachability ) - getCodeFlowAnalyzerForNode , codeFlowAnalyzerCache (analyzer caching) - checkCodeFlowTooComplex , maxCodeComplexity","title":"How the type evaluator uses the CFG"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#the-code-flow-engine-core-algorithms","text":"File: codeFlowEngine.ts Factory: getCodeFlowEngine(evaluator, speculativeTypeTracker) returns a CodeFlowEngine with: createCodeFlowAnalyzer() \u2192 CodeFlowAnalyzer exposing getTypeFromCodeFlow(flowNode, reference|undefined, options?) . getFlowNodeReachability(flowNode, sourceFlowNode?, ignoreNoReturn?) \u2192 reachability over the CFG. narrowConstrainedTypeVar(flowNode, typeVar) \u2192 narrows constrained TypeVars across guards/patterns. printControlFlowGraph \u2192 debug printing with formatControlFlowGraph .","title":"The Code Flow Engine: core algorithms"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#gettypefromcodeflow-backward-traversal-with-narrowing-and-caching","text":"Per-reference caches A separate cache per reference key: combines createKeyForReference(reference) and an optional targetSymbolId to scope cached types. Caches entries as either a concrete Type or an IncompleteType record with incompleteSubtypes for loops. Walk-from-current algorithm Starting at a flowNode , repeatedly: Return cached type if available (respecting \u201cpending\u201d/incomplete generation guards to avoid recursion and churn). Short-circuit on Unreachable* nodes with Never . Skip-through linear nodes updating state: FlowVariableAnnotation , FlowWildcardImport , FlowAssignment.antecedent , FlowCall.antecedent , etc. FlowCall : if isCallNoReturn true, stop exploration on this path (treat as unreachable upstream). FlowAssignment matching the reference: evaluate RHS type via evaluator.evaluateTypesForStatement , handle Unbind (yield UnboundType except for index/member deletes), handle partial-match kill of prior narrowings; special-case TypedDict key assignment narrowing when target is x['literal_key'] . Conditional nodes FlowCondition with True/False / TrueNever/FalseNever : If reference matches, compute typeNarrowingCallback to refine the antecedent type; if Never under implied-else gate, block further exploration. Pattern nodes: FlowNarrowForPattern : evaluate case/match for subject narrowing; can also narrow subexpressions in subject . FlowExhaustedMatch : if subject narrowed to Never at bottom, gate further exploration; otherwise project narrowed type to subexpressions. Finally-gates: FlowPreFinallyGate / FlowPostFinally : toggles a closed-gate set and uses speculative mode inside finally to evaluate \u201cgate-open\u201d types safely. Context managers: FlowPostContextManagerLabel : consults isExceptionContextManager to decide if this path should be blocked based on blockIfSwallowsExceptions . Start node: return options.typeAtStart if provided. Join nodes: FlowBranchLabel : union of types from all antecedents. FlowLabel with LoopLabel : fixed-point over antecedents; track per-antecedent incomplete subtype entries; apply a convergence limit; remove \u201cincomplete unknowns\u201d to encourage convergence. Pseudocode sketch (Python-like, simplified): # Inputs: flowNode, reference (may be None), options # Output: TypeResult(type, isIncomplete) def getTypeFromCodeFlow(flowNode, reference, options): cache = get_cache_for(reference_key(reference, options.target_symbol_id)) def get_from_node(node): while True: entry = cache.lookup(node) if entry.is_complete(): return entry if entry.is_incomplete_for_current_gen(): return entry.clean_union() if cache.is_pending(node): return Unknown(incomplete=True) if node.has_flag('UnreachableStructural') or node.has_flag('UnreachableStaticCondition'): return cache.store(node, Never) if node.is_any('VariableAnnotation', 'WildcardImport'): node = node.antecedent; continue if node.is_call(): if is_call_noreturn(node): return cache.store(node, None) # stop path node = node.antecedent; continue if node.is_assignment(): if matches_reference(node.target, reference, options.target_symbol_id): if node.is_unbind and not is_index_or_member_delete(reference): return cache.store(node, Unbound) rhs = eval_rhs_type(node) return cache.store(node, rhs.type, incomplete=rhs.isIncomplete) if partial_match(node.target, reference): return options.typeAtStart node = node.antecedent; continue if node.is_branch_label(): if reference and unaffected_by_branch(node, reference): node = node.pre_branch_antecedent; continue return join([get_from_node(a) for a in node.antecedents]) if node.is_loop_label(): return solve_loop(node) if node.is_condition(): if reference and not options.skipConditionalNarrowing: narrowed = apply_narrowing(reference, node.expression, positive=node.is_true()) if narrowed is not None: return cache.store(node, narrowed.type, incomplete=narrowed.isIncomplete) node = node.antecedent; continue if node.is_narrow_for_pattern(): res = eval_case_or_match(node.statement) if not reference: if is_never(res.type): return cache.store(node, None, incomplete=res.isIncomplete) else: narrowed = project_subject_narrowing(reference, node.subject, res.type) return cache.store(node, narrowed, incomplete=res.isIncomplete) node = node.antecedent; continue if node.is_exhausted_match(): subj = eval_match(node).type if is_never(subj): return cache.store(node, Never) if reference: narrowed = project_subject_narrowing(reference, node.subject_expression, subj) return cache.store(node, narrowed) node = node.antecedent; continue if node.is_pre_finally_gate(): return evaluate_gate_closed(node) if node.is_post_finally(): return evaluate_gate_open(node) if node.is_post_context_manager_label(): if should_block_path(node): return cache.store(node, None) if node.is_start(): return cache.store(node, options.typeAtStart.type, incomplete=options.typeAtStart.isIncomplete) raise AssertionError('Unexpected FlowNode kind') return get_from_node(flowNode)","title":"getTypeFromCodeFlow: backward traversal with narrowing and caching"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#getflownodereachability-structural-type-based-reachability","text":"Walks backward like getTypeFromCodeFlow but returns a Reachability enum and memoizes per (flowNode, sourceFlowNode?) . Short-circuits with: Structural unreachable flags, unconditional Start checks, and caching. NoReturn calls ( FlowCall ) unless ignoreNoReturn=True . FlowPostContextManagerLabel when no context manager swallows exceptions. Conditional narrowing where the type becomes Never . Pattern narrowing resulting in Never . Joins at labels consider whether any antecedent is reachable; otherwise preserves reason (by-analysis vs static-condition vs structural). Pseudocode sketch: def getFlowNodeReachability(flowNode, sourceFlowNode=None, ignoreNoReturn=False): visited = set(); closed_finally = set(); cache = {} def reach(node): if (node, sourceFlowNode) in cache: return cache[(node, sourceFlowNode)] if node in visited: return 'UnreachableStructural' visited.add(node) if node.has_flag('UnreachableStructural'): return store(node, 'UnreachableStructural') if node.has_flag('UnreachableStaticCondition'): return store(node, 'UnreachableStaticCondition') if node is sourceFlowNode: return store(node, 'Reachable') if node.is_any('VariableAnnotation','Assignment','WildcardImport','ExhaustedMatch'): return tail(node.antecedent) if node.is_narrow_for_pattern(): t = eval_case_or_match(node.statement) if is_never(t.type): return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_condition(): if narrows_to_never(node): return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_call() and not ignoreNoReturn and is_call_noreturn(node): return store(node, 'UnreachableByAnalysis') if node.is_label(): statuses = [reach(a) for a in node.antecedents] if any(s == 'Reachable' for s in statuses): return store(node, 'Reachable') if any(s == 'UnreachableByAnalysis' for s in statuses): return store(node, 'UnreachableByAnalysis') if any(s == 'UnreachableStaticCondition' for s in statuses): return store(node, 'UnreachableStaticCondition') return store(node, 'UnreachableStructural') if node.is_start(): return store(node, 'Reachable' if sourceFlowNode is None else 'UnreachableByAnalysis') if node.is_pre_finally_gate(): if node.id in closed_finally: return store(node, 'UnreachableByAnalysis') return tail(node.antecedent) if node.is_post_finally(): was_closed = node.pre_finally_id in closed_finally closed_finally.add(node.pre_finally_id) try: return store(node, reach(node.antecedent)) finally: if not was_closed: closed_finally.remove(node.pre_finally_id) raise AssertionError def store(node, status): cache[(node, sourceFlowNode)] = status return status def tail(next_node): return reach(next_node) return reach(flowNode)","title":"getFlowNodeReachability: structural + type-based reachability"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#other-algorithms-in-the-engine","text":"narrowConstrainedTypeVar(flowNode, typeVar) : Traverses back through guards and pattern matches to reduce a constrained TypeVar to a single remaining constraint when possible (e.g., isinstance(x, C) filters constraints to those compatible with C ). Handles labels/loops, Pre/PostFinally, and ignores nodes that don\u2019t affect the TypeVar. isCallNoReturn and isFunctionNoReturn : Determines if a call/site is effectively NoReturn (declared NoReturn ; overloads NoReturn ; coroutine third type arg Never ; or flow proves function never reaches after-node). Caches per call node id. isExceptionContextManager : Detects context managers whose __exit__ / __aexit__ return a truthy bool , indicating exception swallowing.","title":"Other algorithms in the engine"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#keys-that-connect-binder-and-evaluator","text":"AnalyzerNodeInfo.setFlowNode / getFlowNode , setAfterFlowNode / getAfterFlowNode attach the current and end-of-block flow nodes to parse nodes. AnalyzerNodeInfo.setCodeFlowExpressions stores a per-scope set of reference keys that actually participate in code flow. typeEvaluator uses this set to skip unnecessary flow analysis. AnalyzerNodeInfo.setCodeFlowComplexity and maxCodeComplexity act as a guardrail against pathological graphs.","title":"Keys that connect binder and evaluator"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#debugging-printing-the-cfg","text":"File: codeFlowUtils.ts , exported formatControlFlowGraph(flowNode: FlowNode) produces an ASCII rendering of the graph rooted at a node, with labels for node kinds. Engine hook: codeFlowEngine.printControlFlowGraph calls this utility (behind an internal flag).","title":"Debugging: printing the CFG"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#end-to-end-flow","text":"1) Parse \u2192 binder.ts constructs the CFG, attaching flow nodes to parse nodes and tracking affected reference keys and complexity. 2) Type evaluation \u2192 typeEvaluator.ts checks complexity and whether the reference participates in code flow, then calls CodeFlowAnalyzer.getTypeFromCodeFlow with the node attached to that parse node. 3) codeFlowEngine.ts traverses backward, applying assignments/guards, narrowing, handling branches/loops/finally/context managers, pattern matching, and NoReturn detection. 4) Results are memoized to avoid recomputation and prevent recursion.","title":"End-to-end flow"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#exact-references-file-and-symbol","text":"CFG node definitions: analyzer/codeFlowTypes.ts FlowFlags , FlowNode , FlowLabel , FlowBranchLabel , FlowAssignment , FlowVariableAnnotation , FlowWildcardImport , FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , FlowCall , FlowPreFinallyGate , FlowPostFinally , FlowPostContextManagerLabel isCodeFlowSupportedForReference , createKeyForReference , createKeysForReferenceSubexpressions CFG construction (binder): analyzer/binder.ts Start: _createStartFlowNode Labels: _createBranchLabel , _createLoopLabel , _finishFlowLabel , _addAntecedent , _bindLoopStatement Conditions: _bindConditional , _createFlowConditional , _bindNeverCondition Visitors building graph: visitIf , visitWhile , visitFor , visitComprehension , visitTernary , visitBinaryOperation , visitUnaryOperation , visitTry , visitWith , visitMatch , visitExcept , visitRaise , visitReturn Assignment/annotation/call/import: _createFlowAssignment , _createVariableAnnotationFlowNode , _createCallFlowNode , _createFlowWildcardImport , _createFlowNarrowForPattern , _createFlowExhaustedMatch Complexity: _codeFlowComplexity and AnalyzerNodeInfo.setCodeFlowComplexity Engine and algorithms: analyzer/codeFlowEngine.ts Factory: getCodeFlowEngine , analyzer: createCodeFlowAnalyzer Narrowing: getTypeFromCodeFlow and helpers for branch/loop/finally nodes Reachability: getFlowNodeReachability TypeVar narrowing: narrowConstrainedTypeVar NoReturn detection: isCallNoReturn , isFunctionNoReturn Context manager detection: isExceptionContextManager Debug: printControlFlowGraph Type evaluator integration: analyzer/typeEvaluator.ts Engine creation and caching: getCodeFlowEngine(...) , getCodeFlowAnalyzerForNode , codeFlowAnalyzerCache Main use sites: getFlowTypeOfReference , getNodeReachability , getAfterNodeReachability Complexity guard: checkCodeFlowTooComplex , constants maxCodeComplexity , maxReturnTypeInferenceCodeFlowComplexity , maxReturnCallSiteTypeInferenceCodeFlowComplexity CFG print utility: analyzer/codeFlowUtils.ts \u2192 formatControlFlowGraph Node info attachment: analyzer/analyzerNodeInfo.ts \u2192 setFlowNode , getFlowNode , setAfterFlowNode , setCodeFlowExpressions , setCodeFlowComplexity","title":"Exact references (file and symbol)"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#notes-on-performance-and-limits","text":"Complexity limits in typeEvaluator.ts avoid high-cost analyses: if exceeded, flow analysis is skipped and results are marked incomplete. Loop convergence uses per-antecedent incomplete entries and a convergence attempt limit; \u201cincomplete unknown\u201d subtypes may be removed to help convergence. Per-reference caches prevent repeated traversals; pending guards avoid re-entrant recursion.","title":"Notes on performance and limits"},{"location":"docs-reverse-engineering/control-flow-graph-and-type-checking/#appendix-related-conceptual-docs","text":"Repo doc: docs/type-concepts-advanced.md \u2192 Sections \"Type Narrowing\", \"Narrowing for Implied Else\", and \"Reachability\". Online docs: https://microsoft.github.io/pyright/#/docs/type-concepts-advanced and https://microsoft.github.io/pyright/#/docs/internals","title":"Appendix: related conceptual docs"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/","text":"Pyright Type Narrowing: An End-to-End Deep Dive This document explains how type narrowing works in Pyright: where it\u2019s triggered, how the binder wires narrowing-capable expressions into the control-flow graph (CFG), how the code flow engine applies narrowing, and the algorithms behind common narrowing forms (truthiness, equality/identity, isinstance/issubclass, user TypeGuard/TypeIs, container membership, discriminated unions, typing.TypedDict, and pattern matching). Citations include file paths and primary function names. Core sources CFG engine: packages/pyright-internal/src/analyzer/codeFlowEngine.ts Narrowing rules: packages/pyright-internal/src/analyzer/typeGuards.ts Pattern matching narrowing: packages/pyright-internal/src/analyzer/patternMatching.ts Binder wiring (collects narrowing expressions for code flow): packages/pyright-internal/src/analyzer/binder.ts Evaluator integration: packages/pyright-internal/src/analyzer/typeEvaluator.ts Concepts: docs/type-concepts-advanced.md (Type Narrowing; Implied Else; Reachability) Where narrowing comes from in the code binder.ts _isNarrowingExpression(...) identifies expressions that can narrow (names, member access, index, and negations, with pragmatic filters for Never-narrowing performance) and records them as code-flow-tracked \u201creference expressions\u201d. Conditional and pattern constructs (visitIf/While/Binary/Unary/Match/With/etc.) generate FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , and other nodes used later by the engine for narrowing. codeFlowEngine.ts getCodeFlowEngine(...).createCodeFlowAnalyzer().getTypeFromCodeFlow(flowNode, reference, options) traverses backward and calls into narrowing callbacks: getTypeNarrowingCallback(...) for boolean/equality/identity/isinstance/TypeGuard/etc. getPatternSubtypeNarrowingCallback(...) from patternMatching.ts to project narrowing to subject subexpressions. Handles implied-else ( TrueNeverCondition / FalseNeverCondition ) and gates (finally/context managers) that affect whether a path continues. typeGuards.ts getTypeNarrowingCallback(...) returns a function that, given the current type of the reference, returns a narrowed type for positive or negative tests. Implements specific narrowing helpers like narrowTypeForTruthiness , narrowTypeForInstanceOrSubclass (isinstance/issubclass/TypeIs), discriminated-literal/None field comparisons, container membership, typed-dict key/value tests, tuple None-index tests, and aliasing of conditions. patternMatching.ts narrowTypeBasedOnPattern(...) and helpers implement narrowing for PEP 634 match/case patterns (sequence, literal, class, mapping, value), with safeguards against combinatorial blow-up. Narrowing pipeline at a glance 1) Binder detects a narrowing-capable test and records reference expressions on the current flow label. Key function: Binder._isNarrowingExpression . 2) The binder emits a control-flow node for the test (e.g., FlowCondition or FlowNarrowForPattern ). 3) The evaluator requests getTypeFromCodeFlow for a reference at a program point; the engine walks backward through flow nodes. 4) When it encounters a test that affects the reference, the engine computes a narrowing callback from typeGuards.getTypeNarrowingCallback (or pattern callbacks) and applies it to the current/reference type, producing a narrowed type. 5) Narrowed types from different branches are unioned; loops use fixed-point iteration; special gates may stop or alter traversal. Key APIs and where they live Engine application sites (codeFlowEngine.ts) Truthy/falsey conditions: getTypeFromCodeFlow checks FlowCondition and calls getTypeNarrowingCallback(...) . Pattern narrowing: getTypeFromCodeFlow handles FlowNarrowForPattern and FlowExhaustedMatch , calling getPatternSubtypeNarrowingCallback to project narrowing to subexpressions. TypedDict key assignment: special handling when the reference is an index with a literal key. Narrowing callbacks (typeGuards.ts) getTypeNarrowingCallback(evaluator, reference, testExpression, isPositiveTest, recursionCount?) Truthiness: narrowTypeForTruthiness . Equality/identity with None, literals, discriminated fields: narrowTypeForIsNone , narrowTypeForDiscriminatedLiteralFieldComparison , narrowTypeForDiscriminatedFieldNoneComparison . isinstance/issubclass/TypeIs: getIsInstanceClassTypes , narrowTypeForInstanceOrSubclass (internal: narrowTypeForInstance , narrowTypeForInstanceOrSubclassInternal , plus Callable/protocol special cases). User-defined TypeGuard/TypeIs: narrowTypeForUserDefinedTypeGuard . Container membership and element projection: getElementTypeForContainerNarrowing , narrowTypeForContainerElementType . Aliased conditions and assignment expressions: getTypeNarrowingCallbackForAliasedCondition , getTypeNarrowingCallbackForAssignmentExpression . Pattern narrowing (patternMatching.ts) narrowTypeBasedOnPattern orchestrates narrowing for match/case patterns. The engine uses companion callbacks for subexpression projection. Pseudocode: getTypeNarrowingCallback usage in the engine # Inside codeFlowEngine.getTypeFromCodeFlow when hitting a FlowCondition if not options.skipConditionalNarrowing and reference is not None: callback = getTypeNarrowingCallback(evaluator, reference, condition.expression, is_positive(condition)) if callback: # Two forms: either narrow the flow-in type (if ref is implicit) or # narrow the ref\u2019s current type when we have a direct reference if condition.reference is None: flow_in = getTypeFromFlowNode(condition.antecedent) narrowed = callback(flow_in.type) if narrowed: return store(narrowed.type, incomplete=flow_in.isIncomplete or narrowed.isIncomplete) else: ref_info = evaluator.getTypeOfExpression(condition.reference) narrowed = callback(ref_info.type) if narrowed: return store(narrowed.type, incomplete=ref_info.isIncomplete or narrowed.isIncomplete) Truthiness narrowing Where: typeGuards.ts \u2192 narrowTypeForTruthiness Trigger: if x: , if not x: Behavior: Removes falsy or truthy components per branch using evaluator\u2019s truthiness rules. Pseudocode: def narrow_type_for_truthiness(type, is_positive): result = [] for t in subtypes(type): if is_positive and can_be_truthy(t): result.append(remove_falsiness(t)) elif not is_positive and can_be_falsy(t): result.append(remove_truthiness(t)) return union(result) Equality/identity narrowing (None, literals, discriminated unions) Where: typeGuards.ts \u2192 helpers like narrowTypeForIsNone , narrowTypeForDiscriminatedLiteralFieldComparison , narrowTypeForDiscriminatedFieldNoneComparison , TypedDict/Tuple discriminated comparisons. Trigger: x is None , x == Literal[...] , obj.tag == 'A' , d['k'] == 'v' . Behavior: Filters union members by compatibility with the discriminant and refines the member types accordingly. isinstance / issubclass / TypeIs Where: typeGuards.ts \u2192 getIsInstanceClassTypes , narrowTypeForInstanceOrSubclass , internals narrowTypeForInstance , narrowTypeForInstanceOrSubclassInternal . Trigger: isinstance(x, C) , issubclass(T, C) , typeguard(x) -> TypeIs[...] . Behavior: Filters the reference type by the class filters, honoring subclass/instance semantics, protocols, Callable, and special forms. TypeIs keeps type variables \u201cbound\u201d differently than isinstance. Pseudocode (simplified): def narrow_instance_or_subclass(var_type, class_filters, is_positive, is_instance_check, is_type_is): if not is_positive: return remove_assignable(var_type, class_filters) kept = [] for vt in subtypes(var_type): if assignable(vt, class_filters, allow_subclasses=is_instance_check): kept.append(bind_typevars(vt) if not is_type_is else vt) return union(kept) User-defined TypeGuard / TypeIs Where: typeGuards.ts \u2192 recognition in getTypeNarrowingCallback , narrowing in narrowTypeForUserDefinedTypeGuard . Behavior: For TypeGuard[T], positive path narrows to T; negative path keeps original (non-strict). For TypeIs[T], applies \u201cstrict\u201d behavior and preserves bindings as required. Container membership and element projection Where: typeGuards.ts \u2192 getElementTypeForContainerNarrowing , narrowTypeForContainerElementType . Trigger: if elem in container: or derived element-type checks. Behavior: Infers element types from specialized containers and narrows reference types accordingly, with safety checks for disjointness and literals. TypedDict-specific narrowing Where: typeGuards.ts \u2192 narrowTypeForTypedDictKey , narrowTypeForDiscriminatedDictEntryComparison ; engine also narrows on literal-key assignments and comparisons. Behavior: Narrows a TypedDict to retain/adjust entry types when keys are tested or assigned literal values; respects extra/required entries and discriminated unions over keys. Pattern matching (PEP 634) Where: patternMatching.ts \u2192 narrowTypeBasedOnPattern and helpers; engine integration via FlowNarrowForPattern and FlowExhaustedMatch with getPatternSubtypeNarrowingCallback . Behavior: Narrows the subject type (and can project to subexpressions) based on the matched pattern: sequences, classes, literals, mappings, as-patterns, value patterns. Includes performance caps like maxSequencePatternTupleExpansionSubtypes . Aliased conditions and assignment expression tests Where: typeGuards.ts \u2192 getTypeNarrowingCallbackForAliasedCondition , getTypeNarrowingCallbackForAssignmentExpression . Trigger: if (n := expr): ... , or if/while condition bound to a local that is then tested elsewhere. Behavior: Traces through aliasing to reuse the same narrowing effect. Integration with CFG and evaluator Engine entry: codeFlowEngine.getCodeFlowEngine(...).createCodeFlowAnalyzer().getTypeFromCodeFlow(...) . Evaluator call sites: typeEvaluator.ts \u2192 getFlowTypeOfReference uses flow only if the binder recorded the expression and complexity thresholds allow. Performance controls: complexity limits in evaluator, recursion prevention and fixed-point convergence in engine, and empirical caps in patternMatching. Tests to consult packages/pyright-internal/src/tests/samples/ contains many sample files: typeGuard*.py , typeNarrowing*.py , TypeNarrowingFalsy* , typeNarrowingCallable* , TypedDict-related samples. packages/pyright-internal/src/tests/typeEvaluator1.test.ts references these samples; use them as ground truth for narrowing behaviors. Quick references (files and symbols) Binder: _isNarrowingExpression , visitIf , visitWhile , visitBinaryOperation , visitUnaryOperation , visitMatch , _createFlowConditional , _createFlowNarrowForPattern , _createFlowExhaustedMatch . Engine: getTypeFromCodeFlow , getPatternSubtypeNarrowingCallback , TypedDict assignment handling. Type guards: getTypeNarrowingCallback , narrowTypeForTruthiness , narrowTypeForInstanceOrSubclass , narrowTypeForUserDefinedTypeGuard , container/typed-dict/discriminant helpers. Pattern matching: narrowTypeBasedOnPattern , helpers for sequence/literal/class/mapping/value patterns. Evaluator integration: getFlowTypeOfReference , checkCodeFlowTooComplex .","title":"Pyright Type Narrowing: An End-to-End Deep Dive"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#pyright-type-narrowing-an-end-to-end-deep-dive","text":"This document explains how type narrowing works in Pyright: where it\u2019s triggered, how the binder wires narrowing-capable expressions into the control-flow graph (CFG), how the code flow engine applies narrowing, and the algorithms behind common narrowing forms (truthiness, equality/identity, isinstance/issubclass, user TypeGuard/TypeIs, container membership, discriminated unions, typing.TypedDict, and pattern matching). Citations include file paths and primary function names. Core sources CFG engine: packages/pyright-internal/src/analyzer/codeFlowEngine.ts Narrowing rules: packages/pyright-internal/src/analyzer/typeGuards.ts Pattern matching narrowing: packages/pyright-internal/src/analyzer/patternMatching.ts Binder wiring (collects narrowing expressions for code flow): packages/pyright-internal/src/analyzer/binder.ts Evaluator integration: packages/pyright-internal/src/analyzer/typeEvaluator.ts Concepts: docs/type-concepts-advanced.md (Type Narrowing; Implied Else; Reachability)","title":"Pyright Type Narrowing: An End-to-End Deep Dive"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#where-narrowing-comes-from-in-the-code","text":"binder.ts _isNarrowingExpression(...) identifies expressions that can narrow (names, member access, index, and negations, with pragmatic filters for Never-narrowing performance) and records them as code-flow-tracked \u201creference expressions\u201d. Conditional and pattern constructs (visitIf/While/Binary/Unary/Match/With/etc.) generate FlowCondition , FlowNarrowForPattern , FlowExhaustedMatch , and other nodes used later by the engine for narrowing. codeFlowEngine.ts getCodeFlowEngine(...).createCodeFlowAnalyzer().getTypeFromCodeFlow(flowNode, reference, options) traverses backward and calls into narrowing callbacks: getTypeNarrowingCallback(...) for boolean/equality/identity/isinstance/TypeGuard/etc. getPatternSubtypeNarrowingCallback(...) from patternMatching.ts to project narrowing to subject subexpressions. Handles implied-else ( TrueNeverCondition / FalseNeverCondition ) and gates (finally/context managers) that affect whether a path continues. typeGuards.ts getTypeNarrowingCallback(...) returns a function that, given the current type of the reference, returns a narrowed type for positive or negative tests. Implements specific narrowing helpers like narrowTypeForTruthiness , narrowTypeForInstanceOrSubclass (isinstance/issubclass/TypeIs), discriminated-literal/None field comparisons, container membership, typed-dict key/value tests, tuple None-index tests, and aliasing of conditions. patternMatching.ts narrowTypeBasedOnPattern(...) and helpers implement narrowing for PEP 634 match/case patterns (sequence, literal, class, mapping, value), with safeguards against combinatorial blow-up.","title":"Where narrowing comes from in the code"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#narrowing-pipeline-at-a-glance","text":"1) Binder detects a narrowing-capable test and records reference expressions on the current flow label. Key function: Binder._isNarrowingExpression . 2) The binder emits a control-flow node for the test (e.g., FlowCondition or FlowNarrowForPattern ). 3) The evaluator requests getTypeFromCodeFlow for a reference at a program point; the engine walks backward through flow nodes. 4) When it encounters a test that affects the reference, the engine computes a narrowing callback from typeGuards.getTypeNarrowingCallback (or pattern callbacks) and applies it to the current/reference type, producing a narrowed type. 5) Narrowed types from different branches are unioned; loops use fixed-point iteration; special gates may stop or alter traversal.","title":"Narrowing pipeline at a glance"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#key-apis-and-where-they-live","text":"Engine application sites (codeFlowEngine.ts) Truthy/falsey conditions: getTypeFromCodeFlow checks FlowCondition and calls getTypeNarrowingCallback(...) . Pattern narrowing: getTypeFromCodeFlow handles FlowNarrowForPattern and FlowExhaustedMatch , calling getPatternSubtypeNarrowingCallback to project narrowing to subexpressions. TypedDict key assignment: special handling when the reference is an index with a literal key. Narrowing callbacks (typeGuards.ts) getTypeNarrowingCallback(evaluator, reference, testExpression, isPositiveTest, recursionCount?) Truthiness: narrowTypeForTruthiness . Equality/identity with None, literals, discriminated fields: narrowTypeForIsNone , narrowTypeForDiscriminatedLiteralFieldComparison , narrowTypeForDiscriminatedFieldNoneComparison . isinstance/issubclass/TypeIs: getIsInstanceClassTypes , narrowTypeForInstanceOrSubclass (internal: narrowTypeForInstance , narrowTypeForInstanceOrSubclassInternal , plus Callable/protocol special cases). User-defined TypeGuard/TypeIs: narrowTypeForUserDefinedTypeGuard . Container membership and element projection: getElementTypeForContainerNarrowing , narrowTypeForContainerElementType . Aliased conditions and assignment expressions: getTypeNarrowingCallbackForAliasedCondition , getTypeNarrowingCallbackForAssignmentExpression . Pattern narrowing (patternMatching.ts) narrowTypeBasedOnPattern orchestrates narrowing for match/case patterns. The engine uses companion callbacks for subexpression projection.","title":"Key APIs and where they live"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#pseudocode-gettypenarrowingcallback-usage-in-the-engine","text":"# Inside codeFlowEngine.getTypeFromCodeFlow when hitting a FlowCondition if not options.skipConditionalNarrowing and reference is not None: callback = getTypeNarrowingCallback(evaluator, reference, condition.expression, is_positive(condition)) if callback: # Two forms: either narrow the flow-in type (if ref is implicit) or # narrow the ref\u2019s current type when we have a direct reference if condition.reference is None: flow_in = getTypeFromFlowNode(condition.antecedent) narrowed = callback(flow_in.type) if narrowed: return store(narrowed.type, incomplete=flow_in.isIncomplete or narrowed.isIncomplete) else: ref_info = evaluator.getTypeOfExpression(condition.reference) narrowed = callback(ref_info.type) if narrowed: return store(narrowed.type, incomplete=ref_info.isIncomplete or narrowed.isIncomplete)","title":"Pseudocode: getTypeNarrowingCallback usage in the engine"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#truthiness-narrowing","text":"Where: typeGuards.ts \u2192 narrowTypeForTruthiness Trigger: if x: , if not x: Behavior: Removes falsy or truthy components per branch using evaluator\u2019s truthiness rules. Pseudocode: def narrow_type_for_truthiness(type, is_positive): result = [] for t in subtypes(type): if is_positive and can_be_truthy(t): result.append(remove_falsiness(t)) elif not is_positive and can_be_falsy(t): result.append(remove_truthiness(t)) return union(result)","title":"Truthiness narrowing"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#equalityidentity-narrowing-none-literals-discriminated-unions","text":"Where: typeGuards.ts \u2192 helpers like narrowTypeForIsNone , narrowTypeForDiscriminatedLiteralFieldComparison , narrowTypeForDiscriminatedFieldNoneComparison , TypedDict/Tuple discriminated comparisons. Trigger: x is None , x == Literal[...] , obj.tag == 'A' , d['k'] == 'v' . Behavior: Filters union members by compatibility with the discriminant and refines the member types accordingly.","title":"Equality/identity narrowing (None, literals, discriminated unions)"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#isinstance-issubclass-typeis","text":"Where: typeGuards.ts \u2192 getIsInstanceClassTypes , narrowTypeForInstanceOrSubclass , internals narrowTypeForInstance , narrowTypeForInstanceOrSubclassInternal . Trigger: isinstance(x, C) , issubclass(T, C) , typeguard(x) -> TypeIs[...] . Behavior: Filters the reference type by the class filters, honoring subclass/instance semantics, protocols, Callable, and special forms. TypeIs keeps type variables \u201cbound\u201d differently than isinstance. Pseudocode (simplified): def narrow_instance_or_subclass(var_type, class_filters, is_positive, is_instance_check, is_type_is): if not is_positive: return remove_assignable(var_type, class_filters) kept = [] for vt in subtypes(var_type): if assignable(vt, class_filters, allow_subclasses=is_instance_check): kept.append(bind_typevars(vt) if not is_type_is else vt) return union(kept)","title":"isinstance / issubclass / TypeIs"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#user-defined-typeguard-typeis","text":"Where: typeGuards.ts \u2192 recognition in getTypeNarrowingCallback , narrowing in narrowTypeForUserDefinedTypeGuard . Behavior: For TypeGuard[T], positive path narrows to T; negative path keeps original (non-strict). For TypeIs[T], applies \u201cstrict\u201d behavior and preserves bindings as required.","title":"User-defined TypeGuard / TypeIs"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#container-membership-and-element-projection","text":"Where: typeGuards.ts \u2192 getElementTypeForContainerNarrowing , narrowTypeForContainerElementType . Trigger: if elem in container: or derived element-type checks. Behavior: Infers element types from specialized containers and narrows reference types accordingly, with safety checks for disjointness and literals.","title":"Container membership and element projection"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#typeddict-specific-narrowing","text":"Where: typeGuards.ts \u2192 narrowTypeForTypedDictKey , narrowTypeForDiscriminatedDictEntryComparison ; engine also narrows on literal-key assignments and comparisons. Behavior: Narrows a TypedDict to retain/adjust entry types when keys are tested or assigned literal values; respects extra/required entries and discriminated unions over keys.","title":"TypedDict-specific narrowing"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#pattern-matching-pep-634","text":"Where: patternMatching.ts \u2192 narrowTypeBasedOnPattern and helpers; engine integration via FlowNarrowForPattern and FlowExhaustedMatch with getPatternSubtypeNarrowingCallback . Behavior: Narrows the subject type (and can project to subexpressions) based on the matched pattern: sequences, classes, literals, mappings, as-patterns, value patterns. Includes performance caps like maxSequencePatternTupleExpansionSubtypes .","title":"Pattern matching (PEP 634)"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#aliased-conditions-and-assignment-expression-tests","text":"Where: typeGuards.ts \u2192 getTypeNarrowingCallbackForAliasedCondition , getTypeNarrowingCallbackForAssignmentExpression . Trigger: if (n := expr): ... , or if/while condition bound to a local that is then tested elsewhere. Behavior: Traces through aliasing to reuse the same narrowing effect.","title":"Aliased conditions and assignment expression tests"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#integration-with-cfg-and-evaluator","text":"Engine entry: codeFlowEngine.getCodeFlowEngine(...).createCodeFlowAnalyzer().getTypeFromCodeFlow(...) . Evaluator call sites: typeEvaluator.ts \u2192 getFlowTypeOfReference uses flow only if the binder recorded the expression and complexity thresholds allow. Performance controls: complexity limits in evaluator, recursion prevention and fixed-point convergence in engine, and empirical caps in patternMatching.","title":"Integration with CFG and evaluator"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#tests-to-consult","text":"packages/pyright-internal/src/tests/samples/ contains many sample files: typeGuard*.py , typeNarrowing*.py , TypeNarrowingFalsy* , typeNarrowingCallable* , TypedDict-related samples. packages/pyright-internal/src/tests/typeEvaluator1.test.ts references these samples; use them as ground truth for narrowing behaviors.","title":"Tests to consult"},{"location":"docs-reverse-engineering/type-narrowing-deep-dive/#quick-references-files-and-symbols","text":"Binder: _isNarrowingExpression , visitIf , visitWhile , visitBinaryOperation , visitUnaryOperation , visitMatch , _createFlowConditional , _createFlowNarrowForPattern , _createFlowExhaustedMatch . Engine: getTypeFromCodeFlow , getPatternSubtypeNarrowingCallback , TypedDict assignment handling. Type guards: getTypeNarrowingCallback , narrowTypeForTruthiness , narrowTypeForInstanceOrSubclass , narrowTypeForUserDefinedTypeGuard , container/typed-dict/discriminant helpers. Pattern matching: narrowTypeBasedOnPattern , helpers for sequence/literal/class/mapping/value patterns. Evaluator integration: getFlowTypeOfReference , checkCodeFlowTooComplex .","title":"Quick references (files and symbols)"}]}